import numpy as np
import matplotlib.pyplot as plt

def generate_pwl_exp_lut(range_min, range_max, num_segments, N, R):
    """
    Generate PWL coefficients for exp(x) over a range with fixed-point quantization.

    Parameters:
        range_min (float): Minimum input value.
        range_max (float): Maximum input value.
        num_segments (int): Number of segments.
        N (int): Total number of fixed-point bits.
        R (int): Number of fractional bits.

    Returns:
        list of tuples: Each tuple contains (slope, intercept) for a segment.
        list of floats: Breakpoints for the segments.
    """
    # Generate breakpoints
    breakpoints = np.linspace(range_min, range_max, num_segments + 1)

    # Compute slopes and intercepts
    slopes = []
    intercepts = []
    for i in range(num_segments):
        x1 = breakpoints[i]
        x2 = breakpoints[i + 1]
        y1 = np.exp(x1)
        y2 = np.exp(x2)

        slope = (y2 - y1) / (x2 - x1)
        intercept = y1 - slope * x1

        # Quantize slope and intercept
        slope_fixed = int(slope * (2 ** R))
        intercept_fixed = int(intercept * (2 ** R))

        # Convert back to floating-point for better understanding
        slope_quantized = slope_fixed / (2 ** R)
        intercept_quantized = intercept_fixed / (2 ** R)

        slopes.append(slope_quantized)
        intercepts.append(intercept_quantized)

    return list(zip(slopes, intercepts)), breakpoints

def generate_systemverilog_lut(lut, breakpoints, N, R):
    """
    Generate a SystemVerilog module for the LUT with precomputed coefficients.

    Parameters:
        lut (list of tuples): PWL coefficients (slope, intercept).
        breakpoints (list of floats): Breakpoints for the segments.
        N (int): Total number of fixed-point bits.
        R (int): Number of fractional bits.

    Returns:
        str: SystemVerilog module as a string.
    """
    module_name = "pwl_exp_lut"
    num_segments = len(lut)
    sv_lines = []

    # Module definition
    sv_lines.append(f"// Module generated by generators/pwl_exp.py")
    sv_lines.append(f"module {module_name}(")
    sv_lines.append("    input  logic [2:0] segment_index,  // Log2(NUM_SEGMENTS)")
    sv_lines.append(f"    output logic signed [FXP_N:0] slope,")
    sv_lines.append(f"    output logic signed [FXP_N:0] intercept,")
    sv_lines.append(f"    output logic signed [FXP_N:0] base")
    sv_lines.append(");")
    sv_lines.append("")

    # LUT declarations
    sv_lines.append(f"    logic signed [FXP_N:0] slopes [{num_segments-1}:0];")
    sv_lines.append(f"    logic signed [FXP_N:0] intercepts [{num_segments-1}:0];")
    sv_lines.append(f"    logic signed [FXP_N:0] bases [{num_segments-1}:0];")
    sv_lines.append("")

    # LUT initialization
    sv_lines.append("    initial begin")
    for i, ((slope, intercept), base) in enumerate(zip(lut, breakpoints[:-1])):
        slope_fixed = int(slope * (2 ** R))
        intercept_fixed = int(intercept * (2 ** R))
        base_fixed = int(base * (2 ** R))

        sv_lines.append(f"        slopes[{i}] = {slope_fixed};")
        sv_lines.append(f"        intercepts[{i}] = {intercept_fixed};")
        sv_lines.append(f"        bases[{i}] = {base_fixed};")
    sv_lines.append("    end")
    sv_lines.append("")

    # Segment selection
    sv_lines.append("    always_comb begin")
    sv_lines.append("        slope = slopes[segment_index];")
    sv_lines.append("        intercept = intercepts[segment_index];")
    sv_lines.append("        base = bases[segment_index];")
    sv_lines.append("    end")
    sv_lines.append("")

    # End module
    sv_lines.append("endmodule")

    return "\n".join(sv_lines)

def plot_pwl_exp(range_min, range_max, lut, breakpoints, num_points=1000):
    """
    Plot the PWL approximation and the actual exp(x) function.

    Parameters:
        range_min (float): Minimum input value.
        range_max (float): Maximum input value.
        lut (list of tuples): PWL coefficients (slope, intercept).
        breakpoints (list of floats): Breakpoints for the segments.
        num_points (int): Number of points to plot.
    """
    x = np.linspace(range_min, range_max, num_points)
    y_actual = np.exp(x)

    y_pwl = np.zeros_like(x)
    for i in range(len(breakpoints) - 1):
        x1 = breakpoints[i]
        x2 = breakpoints[i + 1]
        slope, intercept = lut[i]
        mask = (x >= x1) & (x < x2)
        y_pwl[mask] = slope * x[mask] + intercept

    # Handle the last segment
    slope, intercept = lut[-1]
    mask = x >= breakpoints[-2]
    y_pwl[mask] = slope * x[mask] + intercept

    plt.figure(figsize=(10, 6))
    plt.plot(x, y_actual, label="exp(x) (Actual)", linewidth=2)
    plt.plot(x, y_pwl, label="PWL Approximation", linestyle='--', linewidth=2)
    plt.scatter(breakpoints, np.exp(breakpoints), color='red', label="Breakpoints")
    plt.xlabel("x")
    plt.ylabel("y")
    plt.title("PWL Approximation of exp(x)")
    plt.legend()
    plt.grid()
    plt.show()

# Parameters for the LUT and fixed-point representation
range_min = -2.0
range_max = 2.0
num_segments = 8
N = 16  # Total bits in fixed-point representation
R = 10  # Fractional bits

# Generate LUT
lut, breakpoints = generate_pwl_exp_lut(range_min, range_max, num_segments, N, R)

# Generate SystemVerilog code
sv_code = generate_systemverilog_lut(lut, breakpoints, N, R)

# Plot
plot_pwl_exp(range_min, range_max, lut, breakpoints)


# Save to a file for reference
file_path = "../verilog/pwl_exp_lut.sv"
with open(file_path, "w") as f:
    f.write(sv_code)

file_path
